# 准备流程
+ 1、新建插件，插件模板选择发布代码(TypeScript)
+ 2、vscode打开新插件文件夹，在终端运行npm install -g typescript 安装TypeScript 编译器
+ 3、然后就可以在中断执行tsc main.ts编译了

# 工程结构
+ main 是插件业务逻辑，如果插件内容庞大也可以以此为启动器
    + onPublish：插件加载的时候调用
    + onDestroy：插件销毁的时候调用
+ puerts 算是一个中间层，可以让ts调用unity的代码也可以让unity调用ts的代码
+ editor.d 插件接口基本都在这里
+ 其他的是一些工程配置，和两个代码生成文件

## 官方工程ui界面
+ 参考: https://github.com/fairygui/FairyGUI-Editor 里面有插件示例和全部界面的ui资源
+ 部分界面结构
    + App.groot：UI的根节点，通常用来处理显示弹窗等
    + App.project：整个工程数据，比如工程设置，工程全部包体都可以通过它获取
    + App.mainView：主界面
    + App.docView：打开的组件主要在这个界面显示，可以保存关闭，获取当前打开的组件
    + App.libView：顾名思义就是右边的资源库界面
    + App.inspectorView：检查器，显示当前选中项的相关属性，其中又分成几个分区，分别是
        + info：名字信息
        + basic 基本
        + gaer 属性控制
        + relation 关联
        + effect 效果
        + etc 其他 
        + 通过以上的名字可以可以用GetInspector获取到对应的部分
        + 或者通过 遍历App.inspectorView.visibleInspectors;打印名字来获取一些特殊板块名
    + App.menu 菜单栏 可以在菜单栏上加选项
        

<h1>部分接口</h1>

```typescript
//1. 刷新资源接口
    App.RefreshProject();

//2.获取自定义设置方式 自定义设置获取出来的数据都是string类型
    let setting = App.project.GetSettings("CustomProperties");
    let isAutoRefresh = (setting as FairyEditor.CustomProps).elements.get_Item("isAutoRefresh");

//3. 获取全部包的接口及其遍历方式
    let pkgs = App.project.allPackages;
    for (let i = 0; i < pkgs.Count; i++) {
        let pkg = pkgs.get_Item(i);
    }

//4. 获取文件夹下全部文件路径的方法 值得注意的是这个方法的第三个重载无法使用，在fgui里会报有无效参数的错误
    System.IO.Directory.GetFiles(pkg.basePath, "*.xml");

//5. 获取文件最后修改时间的方式
    let fileDate = System.IO.File.GetLastWriteTime(fileName);   
    let tm = fileDate.getTime() + (fileDate.getTimezoneOffset() * 60 * 1000);

//6. 获取路径下所有文件夹
    let directorys = System.IO.Directory.GetDirectories(pkg.basePath);

//7. 获取发布路径的方式
    let publish = App.project.GetSettings("Publish") as FairyEditor.GlobalPublishSettings;
    console.log("发布路径" + publish.path);

//8. 监听fgui前后台切换
    let onUpdate = function () {
        var active = App.isActive;
    }
    App.add_onUpdate(onUpdate);
    //在onDestry里
    App.remove_onUpdate(onUpdate);

//9.右键菜单
    //在资源库添加右键菜单项
    App.libView.contextMenu
    //在docview添加右键菜单项
    App.docFactory.contextMenu.AddItem
    
//10.监听右键菜单弹出事件 
    App.docFactory.contextMenu.AddEventListener(App.docFactory.contextMenu.onPopup.type, function () {})

//11.刷新inspectorView
    App.inspectorView.Refresh("relation");

//12.复制粘贴关联 FObject的关联的类型是FRelations
    target.relations.Write();//复制
    obj.relations.Read(this.curRelation);//粘贴

//13.基础属性的获取和设置 具体的字段名可以在 FObject 里找
    let comBasic = App.inspectorView.GetInspector("basic").panel;
    comBasic.GetChild("x").asLabel.GetTextField().text;
    docElement.SetProperty("x", this.copyData.x.toString());
```

# 扩展inspectorView
+ 用fgui准备好需要显示的组件的样式和布局发布出来，把发布出来的图集和组件放到插件工程能读取到的文件夹内
```typescript
//提前加载包体
App.pluginManager.LoadUIPackage(App.pluginManager.basePath + "/" + eval("__dirname") + '/Extend');
//创建一个继承PluginInspector的类
    class ComBasicPlugin extends FairyEditor.View.PluginInspector {
        constructor() {
            super(); //如果用ts写的代码转译成js，fgui调用到这里的时候会报错，暂时不知道什么原因
            //创建发布的组件
            this.panel = FairyGUI.UIPackage.CreateObject("Extend", "ComponentBasic")
            //ui刷新函数
            this.updateAction = () => { return this.updateUI(); };
            //设置索引可以更改组件在inspectorView内的显示位置，第一次尝试的时候死活不生效，后来重做一次才生效，也是原因不明
            this.panel.parent.SetChildIndex(this.panel, basicIndex + 1);
        }
    }

    //添加到界面内
    // Register a inspector
    App.inspectorView.AddInspector(() => new ComBasicPlugin(), "ComponentBasic", "");
    //Condition to show it
    App.docFactory.ConnectInspector("ComponentBasic", "", false, false);
```

# 注意事项

+ 有监听或者添加工具栏选项的操作时要记得在onDestroy移除，不然每次加载插件都会重复添加
+ 之前有在网上看过受到puerts的影响插件不能用js的fs，操作文件的话可以用System.IO
+ 给d老师提过两个需求，d老师给的代码里有很多接口都是它伪造的，要用ai的话最好只用来做逻辑辅助
